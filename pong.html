<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pong Game</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(180deg, #0a0a0a 0%, #1a0a14 50%, #0a0a0a 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Bebas Neue', 'Courier New', monospace;
            color: #ff0040;
            overflow: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                repeating-linear-gradient(
                    0deg,
                    rgba(0, 0, 0, 0.15),
                    rgba(0, 0, 0, 0.15) 1px,
                    transparent 1px,
                    transparent 2px
                );
            pointer-events: none;
            z-index: 1;
        }

        #gameCanvas {
            border: 3px solid #ff0040;
            background: #000;
            cursor: none;
            box-shadow:
                0 0 20px rgba(255, 0, 64, 0.5),
                0 0 40px rgba(255, 0, 64, 0.3),
                inset 0 0 60px rgba(255, 0, 64, 0.1);
            position: relative;
            z-index: 2;
        }

        #scoreboard {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 60px;
            margin-bottom: 30px;
            position: relative;
            z-index: 2;
        }

        .score-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .player-name {
            font-size: 24px;
            color: #ff6b9d;
            text-shadow:
                0 0 5px #ff6b9d,
                0 0 10px #ff6b9d,
                0 0 15px #ff6b9d;
            letter-spacing: 3px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .score {
            font-size: 72px;
            color: #ff0040;
            text-shadow:
                0 0 10px #ff0040,
                0 0 20px #ff0040,
                0 0 30px #ff0040,
                0 0 40px #ff0040,
                0 0 70px #ff0040,
                0 0 80px #ff0040;
            font-weight: bold;
        }

        #scoreboard .separator {
            font-size: 72px;
            color: #ff0040;
            text-shadow:
                0 0 10px #ff0040,
                0 0 20px #ff0040,
                0 0 30px #ff0040,
                0 0 40px #ff0040,
                0 0 70px #ff0040,
                0 0 80px #ff0040;
            font-weight: bold;
        }

        #instructions {
            margin-top: 25px;
            text-align: center;
            font-size: 16px;
            color: #ff0040;
            text-shadow:
                0 0 5px #ff0040,
                0 0 10px #ff0040;
            letter-spacing: 2px;
            position: relative;
            z-index: 2;
        }

        #muteButton {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #ff0040;
            border: 2px solid #ff0040;
            padding: 12px 24px;
            font-family: 'Bebas Neue', 'Courier New', monospace;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow:
                0 0 10px rgba(255, 0, 64, 0.5),
                inset 0 0 10px rgba(255, 0, 64, 0.1);
            letter-spacing: 2px;
            z-index: 3;
        }

        #muteButton:hover {
            background: rgba(255, 0, 64, 0.2);
            box-shadow:
                0 0 20px rgba(255, 0, 64, 0.8),
                inset 0 0 20px rgba(255, 0, 64, 0.2);
        }

        #muteButton.muted {
            background: rgba(100, 0, 20, 0.8);
            color: #ff6b9d;
        }

        #particleCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 10;
        }

        /* Power Bar Container */
        #powerBarContainer {
            position: fixed;
            left: 30px;
            top: 200px;
            z-index: 11;
            width: 280px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border: 2px solid #ff0040;
            box-shadow:
                0 0 10px rgba(255, 0, 64, 0.5),
                inset 0 0 10px rgba(255, 0, 64, 0.1);
        }

        #powerBarLabel {
            font-size: 18px;
            color: #ff0040;
            text-shadow:
                0 0 5px #ff0040,
                0 0 10px #ff0040;
            letter-spacing: 2px;
            margin-bottom: 8px;
        }

        #powerBar {
            width: 100%;
            height: 30px;
            background: #1a1a1a;
            border: 3px solid #ff0040;
            box-shadow:
                0 0 10px rgba(255, 0, 64, 0.5),
                inset 0 0 10px rgba(0, 0, 0, 0.8);
            position: relative;
            overflow: hidden;
        }

        #powerBarFill {
            height: 100%;
            width: 0%;
            background: #ff0040;
            transition: width 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 0, 64, 0.8);
        }

        #powerBarFill.ready {
            box-shadow:
                0 0 20px rgba(255, 0, 64, 1),
                0 0 40px rgba(255, 0, 64, 0.8);
            animation: powerGlow 1s infinite;
        }

        @keyframes powerGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 0, 64, 1), 0 0 40px rgba(255, 0, 64, 0.8); }
            50% { box-shadow: 0 0 30px rgba(255, 0, 64, 1), 0 0 60px rgba(255, 0, 64, 1); }
        }

        #powerReadyText {
            color: #ff6b9d;
            font-size: 14px;
            text-shadow:
                0 0 5px #ff6b9d,
                0 0 10px #ff6b9d;
            letter-spacing: 2px;
            margin-top: 8px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #powerReadyText.visible {
            opacity: 1;
        }

        #powerInfo {
            color: #ff0040;
            font-size: 11px;
            text-shadow: 0 0 5px #ff0040;
            letter-spacing: 0.5px;
            margin-top: 5px;
            min-height: 30px;
            line-height: 1.3;
        }

        #activePowerDisplay {
            position: fixed;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff0040;
            font-size: 24px;
            text-shadow:
                0 0 10px #ff0040,
                0 0 20px #ff0040;
            letter-spacing: 3px;
            z-index: 11;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #activePowerDisplay.visible {
            opacity: 1;
        }

        /* Power Info Card */
        #powerInfoCard {
            position: fixed;
            left: 30px;
            top: 400px;
            width: 280px;
            z-index: 11;
        }

        #powerInfoHeader {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff0040;
            padding: 12px 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow:
                0 0 10px rgba(255, 0, 64, 0.5),
                inset 0 0 10px rgba(255, 0, 64, 0.1);
            transition: all 0.3s;
        }

        #powerInfoHeader:hover {
            background: rgba(255, 0, 64, 0.1);
            box-shadow:
                0 0 20px rgba(255, 0, 64, 0.8),
                inset 0 0 20px rgba(255, 0, 64, 0.2);
        }

        #powerInfoHeader h3 {
            color: #ff0040;
            font-size: 16px;
            text-shadow:
                0 0 5px #ff0040,
                0 0 10px #ff0040;
            letter-spacing: 2px;
            margin: 0;
        }

        #powerInfoToggle {
            color: #ff6b9d;
            font-size: 24px;
            transition: transform 0.3s;
        }

        #powerInfoToggle.expanded {
            transform: rotate(180deg);
        }

        #powerInfoContent {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff0040;
            border-top: none;
        }

        #powerInfoContent.expanded {
            max-height: 600px;
        }

        .power-item {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255, 0, 64, 0.3);
        }

        .power-item:last-child {
            border-bottom: none;
        }

        .power-name {
            color: #ff6b9d;
            font-size: 14px;
            text-shadow:
                0 0 5px #ff6b9d,
                0 0 10px #ff6b9d;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }

        .power-description {
            color: #ff0040;
            font-size: 11px;
            text-shadow: 0 0 3px #ff0040;
            letter-spacing: 0.5px;
            opacity: 0.9;
            line-height: 1.3;
        }

        .power-duration {
            color: #ff6b9d;
            font-size: 10px;
            opacity: 0.7;
            margin-top: 3px;
        }

        /* Telekinesis Power Bar (Below Power Info Card) */
        #telekinesisBarContainer {
            position: fixed;
            left: 30px;
            top: 700px;
            z-index: 11;
            width: 280px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border: 2px solid #00d4ff;
            box-shadow:
                0 0 10px rgba(0, 212, 255, 0.5),
                inset 0 0 10px rgba(0, 212, 255, 0.1);
        }

        #telekinesisBarLabel {
            font-size: 18px;
            color: #00d4ff;
            text-shadow:
                0 0 5px #00d4ff,
                0 0 10px #00d4ff;
            letter-spacing: 2px;
            margin-bottom: 8px;
        }

        #telekinesisBar {
            width: 100%;
            height: 30px;
            background: #1a1a1a;
            border: 3px solid #00d4ff;
            box-shadow:
                0 0 10px rgba(0, 212, 255, 0.5),
                inset 0 0 10px rgba(0, 0, 0, 0.8);
            position: relative;
            overflow: hidden;
        }

        #telekinesisBarFill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00d4ff, #00ffaa);
            transition: width 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.8);
        }

        #telekinesisBarFill.ready {
            box-shadow:
                0 0 20px rgba(0, 212, 255, 1),
                0 0 40px rgba(0, 212, 255, 0.8);
            animation: telekinesisGlow 1s infinite;
        }

        @keyframes telekinesisGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 212, 255, 1), 0 0 40px rgba(0, 212, 255, 0.8); }
            50% { box-shadow: 0 0 30px rgba(0, 255, 170, 1), 0 0 60px rgba(0, 212, 255, 1); }
        }

        #telekinesisReadyText {
            color: #00ffaa;
            font-size: 14px;
            text-shadow:
                0 0 5px #00ffaa,
                0 0 10px #00ffaa;
            letter-spacing: 2px;
            margin-top: 8px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #telekinesisReadyText.visible {
            opacity: 1;
        }

        #telekinesisActiveDisplay {
            color: #00d4ff;
            font-size: 16px;
            text-shadow:
                0 0 5px #00d4ff,
                0 0 10px #00d4ff;
            letter-spacing: 1.5px;
            margin-top: 8px;
            text-align: center;
            font-weight: bold;
        }

        /* Stability Bar Container (Right Margin) */
        #stabilityBarContainer {
            position: fixed;
            right: 30px;
            top: 200px;
            z-index: 11;
            width: 60px;
            height: 450px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 10px;
            border: 2px solid #ff0040;
            box-shadow:
                0 0 10px rgba(255, 0, 64, 0.5),
                inset 0 0 10px rgba(255, 0, 64, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #stabilityLabel {
            font-size: 14px;
            color: #ff0040;
            text-shadow:
                0 0 5px #ff0040,
                0 0 10px #ff0040;
            letter-spacing: 1px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            margin-bottom: 15px;
            white-space: nowrap;
        }

        #stabilityBarOuter {
            width: 30px;
            height: 100%;
            background: #1a1a1a;
            border: 2px solid #ff0040;
            box-shadow:
                0 0 10px rgba(255, 0, 64, 0.5),
                inset 0 0 10px rgba(0, 0, 0, 0.8);
            position: relative;
            overflow: hidden;
            flex-grow: 1;
        }

        #stabilityBarFill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to top, #ff0040, #ff6b9d);
            transition: height 0.1s linear;
            box-shadow: 0 0 10px rgba(255, 0, 64, 0.8);
        }

        #stabilityBarFill.low {
            animation: stabilityPulse 0.2s infinite;
        }

        #stabilityBarFill.unstable {
            animation: stabilityFlicker 0.1s infinite;
        }

        @keyframes stabilityPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 0, 64, 0.8); }
            50% { box-shadow: 0 0 20px rgba(255, 0, 64, 1), 0 0 30px rgba(255, 0, 64, 0.8); }
        }

        @keyframes stabilityFlicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        #stabilityPercent {
            color: #ff6b9d;
            font-size: 14px;
            text-shadow:
                0 0 5px #ff6b9d,
                0 0 10px #ff6b9d;
            letter-spacing: 1px;
            margin-top: 10px;
            font-weight: bold;
        }

        #stabilityPercent.unstable {
            color: #ff0040;
            text-shadow:
                0 0 5px #ff0040,
                0 0 10px #ff0040;
        }

        /* Stability Alert Overlay */
        #stabilityAlert {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0040;
            font-size: 48px;
            text-shadow:
                0 0 20px #ff0040,
                0 0 40px #ff0040,
                0 0 60px #ff0040;
            letter-spacing: 5px;
            z-index: 11;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        #stabilityAlert.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <canvas id="particleCanvas"></canvas>
    <button id="muteButton">ðŸ”Š MUSIC ON</button>
    <div id="scoreboard">
        <div class="score-container">
            <div class="player-name">HAWKINS</div>
            <span class="score" id="playerScore">0</span>
        </div>
        <span class="separator">-</span>
        <div class="score-container">
            <div class="player-name">VECNA</div>
            <span class="score" id="computerScore">0</span>
        </div>
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="instructions">
        Use Arrow Keys (Up/Down) or Mouse to control left paddle<br>
        First to 5 wins! Press SPACE or ENTER to restart after game over.
    </div>

    <!-- Power Bar -->
    <div id="powerBarContainer">
        <div id="powerBarLabel">POWER CHARGE</div>
        <div id="powerBar">
            <div id="powerBarFill"></div>
        </div>
        <div id="powerReadyText">âš¡ TAP P TO ACTIVATE âš¡</div>
        <div id="powerInfo"></div>
    </div>

    <!-- Active Power Display -->
    <div id="activePowerDisplay"></div>

    <!-- Power Info Card -->
    <div id="powerInfoCard">
        <div id="powerInfoHeader">
            <h3>âš¡ AVAILABLE POWERS</h3>
            <span id="powerInfoToggle">â–¼</span>
        </div>
        <div id="powerInfoContent">
            <div class="power-item">
                <div class="power-name">1. UPSIDE DOWN</div>
                <div class="power-description">Slows ball to 60% speed - gives you reaction time</div>
                <div class="power-duration">Duration: 4 seconds</div>
            </div>
            <div class="power-item">
                <div class="power-name">2. PSYCHIC SHIELD</div>
                <div class="power-description">Paddle expands 50% taller - easier defense</div>
                <div class="power-duration">Duration: 5 seconds</div>
            </div>
            <div class="power-item">
                <div class="power-name">3. MIND FOG</div>
                <div class="power-description">Computer reaction slowed to 40% - opponent handicap</div>
                <div class="power-duration">Duration: 5 seconds</div>
            </div>
            <div class="power-item">
                <div class="power-name">4. PORTAL JUMP</div>
                <div class="power-description">Ball teleports 100px forward at midline - surprise attack</div>
                <div class="power-duration">Duration: Single-use instant</div>
            </div>
            <div class="power-item">
                <div class="power-name">5. VECNA'S PULL</div>
                <div class="power-description">Ball curves toward your paddle - magnetic attraction</div>
                <div class="power-duration">Duration: 4 seconds</div>
            </div>
        </div>
    </div>

    <!-- Telekinesis Power Bar (Below Power Info Card) -->
    <div id="telekinesisBarContainer">
        <div id="telekinesisBarLabel">TELEKINESIS POWER</div>
        <div id="telekinesisBar">
            <div id="telekinesisBarFill"></div>
        </div>
        <div id="telekinesisReadyText">âš¡ TAP E TO ACTIVATE âš¡</div>
        <div id="telekinesisActiveDisplay"></div>
    </div>

    <!-- Stability Bar (Right Margin) -->
    <div id="stabilityBarContainer">
        <div id="stabilityLabel">EXOTIC MATTER</div>
        <div id="stabilityBarOuter">
            <div id="stabilityBarFill"></div>
        </div>
        <div id="stabilityPercent">100%</div>
    </div>

    <!-- Stability Alert Overlay -->
    <div id="stabilityAlert"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Particle canvas (full screen)
        const particleCanvas = document.getElementById('particleCanvas');
        const particleCtx = particleCanvas.getContext('2d');
        particleCanvas.width = window.innerWidth;
        particleCanvas.height = window.innerHeight;

        // Handle window resize for particle canvas
        window.addEventListener('resize', () => {
            particleCanvas.width = window.innerWidth;
            particleCanvas.height = window.innerHeight;
        });

        // Power UI DOM elements
        const powerBarFill = document.getElementById('powerBarFill');
        const powerReadyText = document.getElementById('powerReadyText');
        const powerInfo = document.getElementById('powerInfo');
        const activePowerDisplay = document.getElementById('activePowerDisplay');

        // Stability UI DOM elements
        const stabilityBarFill = document.getElementById('stabilityBarFill');
        const stabilityPercent = document.getElementById('stabilityPercent');
        const stabilityAlert = document.getElementById('stabilityAlert');

        // Telekinesis UI DOM elements
        const telekinesisBarFill = document.getElementById('telekinesisBarFill');
        const telekinesisReadyText = document.getElementById('telekinesisReadyText');
        const telekinesisActiveDisplay = document.getElementById('telekinesisActiveDisplay');

        // Power info card toggle
        const powerInfoHeader = document.getElementById('powerInfoHeader');
        const powerInfoToggle = document.getElementById('powerInfoToggle');
        const powerInfoContent = document.getElementById('powerInfoContent');

        powerInfoHeader.addEventListener('click', () => {
            const isExpanded = powerInfoContent.classList.contains('expanded');
            if (isExpanded) {
                powerInfoContent.classList.remove('expanded');
                powerInfoToggle.classList.remove('expanded');
            } else {
                powerInfoContent.classList.add('expanded');
                powerInfoToggle.classList.add('expanded');
            }
        });

        // Update power bar UI
        function updatePowerBarUI() {
            // Update bar width
            powerBarFill.style.width = powerSystem.powerCharge + '%';

            // Update color based on current power
            const currentPower = POWERS[powerSystem.currentPowerIndex];
            powerBarFill.style.background = currentPower.color;
            powerBarFill.style.boxShadow = `0 0 10px ${currentPower.color}`;

            // Show/hide ready indicator
            if (powerSystem.powerReady) {
                powerBarFill.classList.add('ready');
                powerReadyText.classList.add('visible');
                powerInfo.textContent = `READY: ${currentPower.name} â€” ${currentPower.description}`;
            } else {
                powerBarFill.classList.remove('ready');
                powerReadyText.classList.remove('visible');
                powerInfo.textContent = '';
            }

            // Update active power display
            if (powerSystem.activePower) {
                const remaining = Math.max(0, powerSystem.activePowerEndTime - performance.now()) / 1000;
                activePowerDisplay.textContent = `${powerSystem.activePower.name} ACTIVE: ${remaining.toFixed(1)}s`;
                activePowerDisplay.classList.add('visible');
            } else {
                activePowerDisplay.classList.remove('visible');
            }
        }

        // Update Telekinesis bar UI
        function updateTelekinesisBarUI() {
            // Update bar width
            telekinesisBarFill.style.width = telekinesisSystem.charge + '%';

            // Show/hide ready indicator
            if (telekinesisSystem.ready) {
                telekinesisBarFill.classList.add('ready');
                telekinesisReadyText.classList.add('visible');
            } else {
                telekinesisBarFill.classList.remove('ready');
                telekinesisReadyText.classList.remove('visible');
            }

            // Update active display
            if (telekinesisSystem.active) {
                const remaining = Math.max(0, telekinesisSystem.endTime - performance.now()) / 1000;
                telekinesisActiveDisplay.textContent = `TELEKINESIS ACTIVE: ${remaining.toFixed(1)}s`;
            } else {
                telekinesisActiveDisplay.textContent = '';
            }
        }

        // Update stability bar UI
        function updateStabilityBarUI() {
            // Update bar height (fills from bottom)
            stabilityBarFill.style.height = stabilitySystem.stability + '%';

            // Update percentage text
            stabilityPercent.textContent = Math.floor(stabilitySystem.stability) + '%';

            // Update classes based on state
            if (stabilitySystem.mode === "STABLE") {
                stabilityBarFill.classList.remove('unstable');
                stabilityPercent.classList.remove('unstable');

                if (stabilitySystem.stability < 20) {
                    stabilityBarFill.classList.add('low');
                } else {
                    stabilityBarFill.classList.remove('low');
                }

                stabilityAlert.classList.remove('visible');
            } else {
                // Unstable mode
                stabilityBarFill.classList.remove('low');
                stabilityBarFill.classList.add('unstable');
                stabilityPercent.classList.add('unstable');

                // Show alert
                const alertText = stabilitySystem.unstableTimer < 1000 ? 'REALITY FRACTURE' : 'STABILITY LOST';
                stabilityAlert.textContent = alertText;
                stabilityAlert.classList.add('visible');
            }
        }

        // Stranger Things-Inspired Synthwave Music Generator
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let isMuted = false;
        let audioInitialized = false;

        // Master gain for volume control
        const masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.3;
        masterGain.connect(audioCtx.destination);

        // ===== TIMING & SEQUENCER =====
        const BPM = 84;
        const quarterNoteTime = 60 / BPM; // ~0.714s
        const sixteenthNoteTime = quarterNoteTime / 4; // ~0.178s
        const scheduleAheadTime = 0.1; // Schedule 100ms ahead
        const lookaheadInterval = 25; // Check every 25ms

        let currentSixteenthNote = 0;
        let nextNoteTime = 0.0;
        let timerID;

        // ===== MUSICAL DATA (C MINOR) =====
        // Original hypnotic arpeggio inspired by i-VI-III-VII progression
        // Cm (C Eb G) â†’ Ab (Ab C Eb) â†’ Eb (Eb G Bb) â†’ Bb (Bb D F)
        const arpPattern = [
            // Bar 1-2: Cm arpeggio
            { note: 523.25, step: 0 },  // C5
            { note: 622.25, step: 2 },  // Eb5
            { note: 783.99, step: 4 },  // G5
            { note: 622.25, step: 6 },  // Eb5
            // Bar 3-4: Ab arpeggio
            { note: 830.61, step: 8 },  // Ab5
            { note: 523.25, step: 10 }, // C5
            { note: 622.25, step: 12 }, // Eb5
            { note: 523.25, step: 14 }, // C5
            // Bar 5-6: Eb arpeggio
            { note: 622.25, step: 16 }, // Eb5
            { note: 783.99, step: 18 }, // G5
            { note: 932.33, step: 20 }, // Bb5
            { note: 783.99, step: 22 }, // G5
            // Bar 7-8: Bb arpeggio
            { note: 932.33, step: 24 }, // Bb5
            { note: 587.33, step: 26 }, // D5
            { note: 698.46, step: 28 }, // F5
            { note: 587.33, step: 30 }, // D5
        ];

        const bassPattern = [
            { note: 130.81, step: 0, duration: 8 },  // C3 (hold for 8 16ths)
            { note: 207.65, step: 8, duration: 8 },  // Ab3
            { note: 155.56, step: 16, duration: 8 }, // Eb3
            { note: 233.08, step: 24, duration: 8 }, // Bb3
        ];

        // ===== EFFECTS CREATION =====

        // Impulse reverb (simple convolver)
        function createReverb() {
            const convolver = audioCtx.createConvolver();
            const rate = audioCtx.sampleRate;
            const length = rate * 2.5; // 2.5s decay
            const impulse = audioCtx.createBuffer(2, length, rate);
            const left = impulse.getChannelData(0);
            const right = impulse.getChannelData(1);

            for (let i = 0; i < length; i++) {
                const decay = Math.exp(-4 * i / length);
                left[i] = (Math.random() * 2 - 1) * decay * 0.5;
                right[i] = (Math.random() * 2 - 1) * decay * 0.5;
            }

            convolver.buffer = impulse;
            return convolver;
        }

        // Tempo-synced delay (dotted 8th = 3/4 quarter note)
        function createDelay() {
            const delay = audioCtx.createDelay(2);
            const feedback = audioCtx.createGain();
            const wetGain = audioCtx.createGain();

            delay.delayTime.value = quarterNoteTime * 0.75; // Dotted 8th
            feedback.gain.value = 0.35;
            wetGain.gain.value = 0.2;

            // Feedback loop
            delay.connect(feedback);
            feedback.connect(delay);
            delay.connect(wetGain);

            return { input: delay, output: wetGain };
        }

        // Saturation for bass warmth
        function createSaturation() {
            const shaper = audioCtx.createWaveShaper();
            const samples = 256;
            const curve = new Float32Array(samples);
            const amount = 0.6;

            for (let i = 0; i < samples; i++) {
                const x = (i / samples) * 2 - 1;
                curve[i] = Math.tanh(x * amount * 4);
            }

            shaper.curve = curve;
            shaper.oversample = '2x';
            return shaper;
        }

        // Initialize effects chain
        const reverbNode = createReverb();
        const delayEffect = createDelay();
        const bassShaper = createSaturation();

        const reverbWet = audioCtx.createGain();
        reverbWet.gain.value = 0.12;
        reverbNode.connect(reverbWet);
        reverbWet.connect(masterGain);

        delayEffect.output.connect(masterGain);

        // ===== SOUND SYNTHESIS =====

        // Arp synth: dual detuned saws with filter envelope
        function playArpNote(frequency, time) {
            if (isMuted) return;

            const noteLength = sixteenthNoteTime * 0.85;

            // Dual sawtooth oscillators (analog thickness)
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            osc1.type = 'sawtooth';
            osc2.type = 'sawtooth';
            osc1.frequency.value = frequency;
            osc2.frequency.value = frequency;
            osc1.detune.value = 10;  // +10 cents
            osc2.detune.value = -10; // -10 cents

            // Mixer
            const mixer = audioCtx.createGain();
            mixer.gain.value = 0.4;
            osc1.connect(mixer);
            osc2.connect(mixer);

            // Lowpass filter with envelope
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.Q.value = 4;
            filter.frequency.value = 600;

            // Filter envelope: bright attack, quick decay
            filter.frequency.setValueAtTime(3500, time);
            filter.frequency.exponentialRampToValueAtTime(600, time + 0.08);

            mixer.connect(filter);

            // Amplitude envelope (pumping feel)
            const amp = audioCtx.createGain();
            amp.gain.value = 0;
            filter.connect(amp);

            amp.gain.setValueAtTime(0, time);
            amp.gain.linearRampToValueAtTime(0.15, time + 0.003);
            amp.gain.linearRampToValueAtTime(0.11, time + noteLength * 0.6);
            amp.gain.linearRampToValueAtTime(0, time + noteLength);

            // Route to effects and master
            amp.connect(delayEffect.input);
            amp.connect(reverbNode);
            amp.connect(masterGain);

            osc1.start(time);
            osc2.start(time);
            osc1.stop(time + noteLength);
            osc2.stop(time + noteLength);
        }

        // Bass synth: triangle/saw with heavy lowpass and saturation
        function playBassNote(frequency, time, duration) {
            if (isMuted) return;

            const noteLength = sixteenthNoteTime * duration * 0.95;

            const osc = audioCtx.createOscillator();
            osc.type = 'triangle';
            osc.frequency.value = frequency;

            // Through saturation
            osc.connect(bassShaper);

            // Heavy lowpass
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 350;
            filter.Q.value = 2;
            bassShaper.connect(filter);

            // Amp envelope
            const amp = audioCtx.createGain();
            amp.gain.value = 0;
            filter.connect(amp);

            amp.gain.setValueAtTime(0, time);
            amp.gain.linearRampToValueAtTime(0.28, time + 0.015);
            amp.gain.linearRampToValueAtTime(0.22, time + noteLength - 0.03);
            amp.gain.linearRampToValueAtTime(0, time + noteLength);

            amp.connect(masterGain);

            osc.start(time);
            osc.stop(time + noteLength);
        }

        // ===== SEQUENCER =====

        // Lookahead scheduler: schedules notes ahead to avoid timing drift
        function scheduler() {
            // Schedule all notes that fall within the lookahead window
            while (nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
                scheduleNote(currentSixteenthNote, nextNoteTime);
                nextStep();
            }
        }

        function scheduleNote(stepNumber, time) {
            const step = stepNumber % 32; // 32-step pattern

            // Check arp pattern
            const arpNote = arpPattern.find(n => n.step === step);
            if (arpNote) {
                playArpNote(arpNote.note, time);
            }

            // Check bass pattern
            const bassNote = bassPattern.find(n => n.step === step);
            if (bassNote) {
                playBassNote(bassNote.note, time, bassNote.duration);
            }
        }

        function nextStep() {
            nextNoteTime += sixteenthNoteTime;
            currentSixteenthNote++;
        }

        // ===== AUTOPLAY POLICY =====

        function initAudio() {
            if (audioInitialized) return;

            // Resume suspended context
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            // Start sequencer
            currentSixteenthNote = 0;
            nextNoteTime = audioCtx.currentTime + 0.05;
            timerID = setInterval(scheduler, lookaheadInterval);

            audioInitialized = true;
        }

        // Auto-init on first interaction
        document.addEventListener('click', initAudio, { once: true });
        document.addEventListener('keydown', initAudio, { once: true });

        // ===== MUTE BUTTON =====

        const muteButton = document.getElementById('muteButton');
        muteButton.addEventListener('click', () => {
            // Ensure audio is initialized
            if (!audioInitialized) initAudio();

            isMuted = !isMuted;
            if (isMuted) {
                muteButton.textContent = 'ðŸ”‡ MUSIC OFF';
                muteButton.classList.add('muted');
                masterGain.gain.value = 0;
            } else {
                muteButton.textContent = 'ðŸ”Š MUSIC ON';
                muteButton.classList.remove('muted');
                masterGain.gain.value = 0.3;
            }
        });

        // Game objects
        const game = {
            playerScore: 0,
            computerScore: 0,
            maxScore: 5,
            isOver: false,
            isPaused: false
        };

        // ===== POWER SYSTEM =====

        const powerSystem = {
            hitStreak: 0,
            powerCharge: 0, // 0-100
            powerReady: false,
            currentPowerIndex: 0,
            activePower: null,
            activePowerEndTime: 0
        };

        // Power definitions (Stranger Things themed)
        const POWERS = [
            {
                name: "UPSIDE DOWN",
                description: "Slow time - ball moves at 60% speed",
                duration: 4000, // 4 seconds
                color: '#ff0040',
                onActivate() {
                    this.originalSpeedX = ball.speedX;
                    this.originalSpeedY = ball.speedY;
                    ball.speedX *= 0.6;
                    ball.speedY *= 0.6;
                },
                onUpdate(dt) {},
                onEnd() {
                    ball.speedX = this.originalSpeedX;
                    ball.speedY = this.originalSpeedY;
                }
            },
            {
                name: "PSYCHIC SHIELD",
                description: "Paddle expands by 50% height",
                duration: 5000, // 5 seconds
                color: '#ff6b9d',
                onActivate() {
                    this.originalHeight = player.height;
                    player.height *= 1.5;
                },
                onUpdate(dt) {},
                onEnd() {
                    player.height = this.originalHeight;
                }
            },
            {
                name: "MIND FOG",
                description: "Computer reaction slowed",
                duration: 5000, // 5 seconds
                color: '#ff0040',
                onActivate() {
                    this.originalSpeed = computer.speed;
                    computer.speed *= 0.4; // 40% of normal speed
                },
                onUpdate(dt) {},
                onEnd() {
                    computer.speed = this.originalSpeed;
                }
            },
            {
                name: "PORTAL JUMP",
                description: "Ball teleports forward once at midline",
                duration: 10000, // 10 seconds window
                color: '#ff6b9d',
                onActivate() {
                    this.hasJumped = false;
                },
                onUpdate(dt) {
                    // Trigger teleport when ball crosses midline moving right
                    if (!this.hasJumped && ball.x > canvas.width / 2 && ball.speedX > 0) {
                        ball.x += 100; // Teleport 100px forward
                        this.hasJumped = true;
                        // End power immediately after use
                        powerSystem.activePowerEndTime = 0;
                    }
                },
                onEnd() {
                    this.hasJumped = false;
                }
            },
            {
                name: "VECNA'S PULL",
                description: "Ball curves toward your paddle",
                duration: 4000, // 4 seconds
                color: '#ff0040',
                onActivate() {},
                onUpdate(dt) {
                    // Apply subtle upward/downward force toward paddle center
                    const paddleCenter = player.y + player.height / 2;
                    const diff = paddleCenter - ball.y;
                    const pullStrength = 0.15; // pixels per frame

                    if (Math.abs(diff) > 5) {
                        ball.y += Math.sign(diff) * pullStrength;
                    }
                },
                onEnd() {}
            }
        ];

        // ===== TELEKINESIS SYSTEM =====

        const telekinesisSystem = {
            hitStreak: 0,
            charge: 0, // 0-100
            ready: false,
            active: false,
            endTime: 0,
            duration: 5000, // 5 seconds
            steerAcceleration: 450, // pixels per second squared
            maxSteerSpeed: 550 // max ball speed during telekinesis
        };

        // Get next power (cycle through)
        function getNextPower() {
            powerSystem.currentPowerIndex = (powerSystem.currentPowerIndex + 1) % POWERS.length;
            return POWERS[powerSystem.currentPowerIndex];
        }

        // Activate current power
        function activatePower() {
            if (!powerSystem.powerReady || game.isOver) return;

            const power = POWERS[powerSystem.currentPowerIndex];
            powerSystem.activePower = power;
            powerSystem.activePowerEndTime = performance.now() + power.duration;
            powerSystem.powerReady = false;
            powerSystem.powerCharge = 0;
            powerSystem.hitStreak = 0;

            // Call power's activate function
            power.onActivate();

            // Move to next power
            getNextPower();
        }

        // Update active power
        function updatePower(dt) {
            if (powerSystem.activePower) {
                const now = performance.now();

                // Update power logic
                powerSystem.activePower.onUpdate(dt);

                // Check if power expired
                if (now >= powerSystem.activePowerEndTime) {
                    powerSystem.activePower.onEnd();
                    powerSystem.activePower = null;
                }
            }
        }

        // Increment hit streak (call when player hits ball)
        function incrementHitStreak() {
            powerSystem.hitStreak++;
            powerSystem.powerCharge = Math.min(powerSystem.hitStreak * 20, 100);

            if (powerSystem.powerCharge >= 100) {
                powerSystem.powerReady = true;
            }
        }

        // Reset hit streak (call when player misses)
        function resetHitStreak() {
            powerSystem.hitStreak = 0;
            powerSystem.powerCharge = 0;
            powerSystem.powerReady = false;
        }

        // Increment Telekinesis hit streak (call when player hits ball)
        function incrementTelekinesisStreak() {
            telekinesisSystem.hitStreak++;
            // 11 hits required = 100/11 â‰ˆ 9.09% per hit
            telekinesisSystem.charge = Math.min((telekinesisSystem.hitStreak * 100) / 11, 100);

            if (telekinesisSystem.charge >= 100) {
                telekinesisSystem.ready = true;
            }
        }

        // Reset Telekinesis streak (call when player misses)
        function resetTelekinesisStreak() {
            telekinesisSystem.hitStreak = 0;
            telekinesisSystem.charge = 0;
            telekinesisSystem.ready = false;
        }

        // Activate Telekinesis power
        function activateTelekinesis() {
            if (!telekinesisSystem.ready || telekinesisSystem.active || game.isOver) return;

            telekinesisSystem.active = true;
            telekinesisSystem.endTime = performance.now() + telekinesisSystem.duration;

            // Reset charge and ready state
            telekinesisSystem.charge = 0;
            telekinesisSystem.ready = false;
            telekinesisSystem.hitStreak = 0;
        }

        // Update Telekinesis steering (apply arrow key control to ball)
        function updateTelekinesis(dt) {
            if (!telekinesisSystem.active) return;

            const now = performance.now();

            // Check if Telekinesis expired
            if (now >= telekinesisSystem.endTime) {
                telekinesisSystem.active = false;
                return;
            }

            // Apply steering based on arrow keys
            const steerAccel = telekinesisSystem.steerAcceleration * dt;

            if (keys.up) {
                ball.speedY -= steerAccel;
            }
            if (keys.down) {
                ball.speedY += steerAccel;
            }
            if (keys.left) {
                ball.speedX -= steerAccel;
            }
            if (keys.right) {
                ball.speedX += steerAccel;
            }

            // Clamp to max steer speed
            const speed = Math.sqrt(ball.speedX ** 2 + ball.speedY ** 2);
            if (speed > telekinesisSystem.maxSteerSpeed) {
                const scale = telekinesisSystem.maxSteerSpeed / speed;
                ball.speedX *= scale;
                ball.speedY *= scale;
            }

            // Apply gentle damping to prevent runaway velocity
            ball.speedX *= 0.995;
            ball.speedY *= 0.995;
        }

        // ===== EXOTIC MATTER STABILITY SYSTEM =====

        const stabilitySystem = {
            stability: 100, // 0-100%
            mode: "STABLE", // "STABLE" or "UNSTABLE"
            stableTimer: 0, // Timer for stable phase (10 seconds)
            unstableTimer: 0, // Timer for unstable phase (5 seconds)
            STABLE_DURATION: 10000, // 10 seconds in ms
            UNSTABLE_DURATION: 5000, // 5 seconds in ms
            WARNING_THRESHOLD: 1000, // 1 second before instability
            obstacles: [],
            shakeIntensity: 0,
            lastCollisionFrame: 0
        };

        // Generate random obstacles
        function generateObstacles() {
            const obstacles = [];
            const count = 3 + Math.floor(Math.random() * 5); // 3-7 obstacles
            const safeZoneX = 150; // Keep away from paddles
            const safeZoneY = 100; // Buffer from edges

            for (let i = 0; i < count; i++) {
                let attempts = 0;
                let validPosition = false;
                let obstacle;

                while (!validPosition && attempts < 50) {
                    const width = 30 + Math.random() * 50; // 30-80px
                    const height = 30 + Math.random() * 50;
                    const x = safeZoneX + Math.random() * (canvas.width - 2 * safeZoneX - width);
                    const y = safeZoneY + Math.random() * (canvas.height - 2 * safeZoneY - height);

                    obstacle = {
                        x, y, width, height,
                        driftX: (Math.random() - 0.5) * 0.3, // Subtle drift
                        driftY: (Math.random() - 0.5) * 0.3,
                        rotation: 0
                    };

                    // Check if too close to ball
                    const distToBall = Math.hypot(ball.x - (x + width/2), ball.y - (y + height/2));
                    if (distToBall > 100) {
                        validPosition = true;
                    }
                    attempts++;
                }

                if (validPosition) {
                    obstacles.push(obstacle);
                }
            }

            return obstacles;
        }

        // Ball-obstacle collision
        function checkObstacleCollisions(currentFrame) {
            // Prevent double-collisions in same frame
            if (stabilitySystem.lastCollisionFrame === currentFrame) return;

            for (const obs of stabilitySystem.obstacles) {
                // Simple AABB collision
                const closestX = Math.max(obs.x, Math.min(ball.x, obs.x + obs.width));
                const closestY = Math.max(obs.y, Math.min(ball.y, obs.y + obs.height));
                const distX = ball.x - closestX;
                const distY = ball.y - closestY;
                const distance = Math.sqrt(distX * distX + distY * distY);

                if (distance < ball.radius) {
                    // Collision detected - determine reflection axis
                    const overlapX = ball.radius - Math.abs(ball.x - (obs.x + obs.width / 2)) + obs.width / 2;
                    const overlapY = ball.radius - Math.abs(ball.y - (obs.y + obs.height / 2)) + obs.height / 2;

                    if (overlapX < overlapY) {
                        ball.speedX = -ball.speedX;
                        // Push ball out
                        ball.x += ball.speedX > 0 ? 5 : -5;
                    } else {
                        ball.speedY = -ball.speedY;
                        // Push ball out
                        ball.y += ball.speedY > 0 ? 5 : -5;
                    }

                    stabilitySystem.lastCollisionFrame = currentFrame;
                    return; // Only one collision per frame
                }
            }
        }

        // Update stability system
        function updateStability(dt) {
            if (game.isOver) return;

            if (stabilitySystem.mode === "STABLE") {
                // Drain stability over 10 seconds
                stabilitySystem.stableTimer += dt;
                stabilitySystem.stability = 100 - (stabilitySystem.stableTimer / stabilitySystem.STABLE_DURATION) * 100;
                stabilitySystem.stability = Math.max(0, stabilitySystem.stability);

                // Check if we hit 0%
                if (stabilitySystem.stability <= 0) {
                    // Enter UNSTABLE mode
                    stabilitySystem.mode = "UNSTABLE";
                    stabilitySystem.unstableTimer = 0;
                    stabilitySystem.shakeIntensity = 1;
                    stabilitySystem.obstacles = generateObstacles();
                }
            } else if (stabilitySystem.mode === "UNSTABLE") {
                // Unstable phase lasts 5 seconds
                stabilitySystem.unstableTimer += dt;

                // Taper shake intensity
                stabilitySystem.shakeIntensity = Math.max(0, 1 - stabilitySystem.unstableTimer / stabilitySystem.UNSTABLE_DURATION);

                // Update obstacles (subtle drift)
                for (const obs of stabilitySystem.obstacles) {
                    obs.x += obs.driftX;
                    obs.y += obs.driftY;
                    obs.rotation += 0.01;

                    // Keep in bounds
                    obs.x = Math.max(0, Math.min(canvas.width - obs.width, obs.x));
                    obs.y = Math.max(0, Math.min(canvas.height - obs.height, obs.y));
                }

                // Check collisions
                checkObstacleCollisions(performance.now());

                // Check if unstable phase is over
                if (stabilitySystem.unstableTimer >= stabilitySystem.UNSTABLE_DURATION) {
                    // Return to STABLE
                    stabilitySystem.mode = "STABLE";
                    stabilitySystem.stability = 100;
                    stabilitySystem.stableTimer = 0;
                    stabilitySystem.obstacles = [];
                    stabilitySystem.shakeIntensity = 0;
                }
            }
        }


        // Draw obstacles
        function drawObstacles() {
            ctx.save();
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#ff6b9d';

            for (const obs of stabilitySystem.obstacles) {
                ctx.save();
                ctx.translate(obs.x + obs.width / 2, obs.y + obs.height / 2);
                ctx.rotate(obs.rotation);
                ctx.fillStyle = 'rgba(255, 107, 157, 0.6)';
                ctx.fillRect(-obs.width / 2, -obs.height / 2, obs.width, obs.height);
                ctx.strokeStyle = '#ff6b9d';
                ctx.lineWidth = 2;
                ctx.strokeRect(-obs.width / 2, -obs.height / 2, obs.width, obs.height);
                ctx.restore();
            }

            ctx.restore();
        }

        const ball = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 8,
            speedX: 5,
            speedY: 5,
            maxSpeed: 12
        };

        const paddleWidth = 12;
        const paddleHeight = 100;

        const player = {
            x: 20,
            y: canvas.height / 2 - paddleHeight / 2,
            width: paddleWidth,
            height: paddleHeight,
            speed: 8
        };

        const computer = {
            x: canvas.width - 20 - paddleWidth,
            y: canvas.height / 2 - paddleHeight / 2,
            width: paddleWidth,
            height: paddleHeight,
            speed: 6
        };

        // Input handling
        const keys = {
            up: false,
            down: false,
            left: false,
            right: false
        };

        let mouseY = canvas.height / 2;
        let usingKeyboard = false;

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp') {
                keys.up = true;
                usingKeyboard = true;
            }
            if (e.key === 'ArrowDown') {
                keys.down = true;
                usingKeyboard = true;
            }
            if (e.key === 'ArrowLeft') {
                keys.left = true;
            }
            if (e.key === 'ArrowRight') {
                keys.right = true;
            }
            if ((e.key === ' ' || e.key === 'Enter') && game.isOver) {
                e.preventDefault();
                resetGame();
            }
            // Power activation
            if (e.key === 'p' || e.key === 'P') {
                e.preventDefault();
                activatePower();
            }
            // Telekinesis activation
            if (e.key === 'e' || e.key === 'E') {
                e.preventDefault();
                activateTelekinesis();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowUp') keys.up = false;
            if (e.key === 'ArrowDown') keys.down = false;
            if (e.key === 'ArrowLeft') keys.left = false;
            if (e.key === 'ArrowRight') keys.right = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseY = e.clientY - rect.top;
            usingKeyboard = false;
        });

        // ===== PARTICLE SYSTEM (Stranger Things floating embers) =====

        const particlePool = [];
        const activeParticles = [];
        const MAX_PARTICLES = 120;
        const SPAWN_RATE = 0.4; // Particles per frame (probabilistic)

        // Particle object (reusable)
        function createParticle() {
            return {
                x: 0,
                y: 0,
                vx: 0,
                vy: 0,
                size: 0,
                alpha: 0,
                life: 0,
                maxLife: 0,
                color: '#ff0040',
                wobblePhase: 0,
                wobbleSpeed: 0,
                wobbleAmount: 0,
                active: false
            };
        }

        // Initialize particle pool
        for (let i = 0; i < MAX_PARTICLES; i++) {
            particlePool.push(createParticle());
        }

        // Spawn a new particle
        function spawnParticle() {
            // Find inactive particle from pool
            let particle = particlePool.find(p => !p.active);
            if (!particle) return; // Pool exhausted

            // Random spawn position above viewport (entire browser width)
            particle.x = Math.random() * window.innerWidth;
            particle.y = -10 - Math.random() * 20;

            // Downward velocity with variation
            particle.vy = 0.3 + Math.random() * 0.8; // 0.3 to 1.1 px/frame
            particle.vx = (Math.random() - 0.5) * 0.3; // Slight horizontal drift

            // Wobble parameters (for organic horizontal motion)
            particle.wobblePhase = Math.random() * Math.PI * 2;
            particle.wobbleSpeed = 0.02 + Math.random() * 0.03;
            particle.wobbleAmount = 0.3 + Math.random() * 0.7;

            // Size variation: bigger particles now
            const rand = Math.random();
            if (rand > 0.95) {
                particle.size = 4.5 + Math.random() * 2; // Rare bright speck (4.5-6.5px)
            } else if (rand > 0.7) {
                particle.size = 3 + Math.random() * 1.5; // Medium (3-4.5px)
            } else {
                particle.size = 1.8 + Math.random() * 1.2; // Small (1.8-3px)
            }

            // Lifetime: 3-8 seconds at 60fps = 180-480 frames
            particle.maxLife = 180 + Math.random() * 300;
            particle.life = 0;

            // Color: mostly red, occasionally pink
            particle.color = Math.random() > 0.7 ? '#ff6b9d' : '#ff0040';

            particle.alpha = 0;
            particle.active = true;
            activeParticles.push(particle);
        }

        // Update all particles
        function updateParticles() {
            // Spawn new particles probabilistically
            if (Math.random() < SPAWN_RATE && activeParticles.length < MAX_PARTICLES) {
                spawnParticle();
            }

            // Update each active particle
            for (let i = activeParticles.length - 1; i >= 0; i--) {
                const p = activeParticles[i];

                // Age particle
                p.life++;

                // Fade in/out
                const lifeFraction = p.life / p.maxLife;
                if (lifeFraction < 0.1) {
                    // Fade in
                    p.alpha = lifeFraction * 10;
                } else if (lifeFraction > 0.8) {
                    // Fade out
                    p.alpha = (1 - lifeFraction) * 5;
                } else {
                    // Full opacity (but low alpha overall)
                    p.alpha = 1;
                }
                p.alpha *= 0.25; // Keep it subtle

                // Move particle
                p.y += p.vy;
                p.x += p.vx;

                // Add horizontal wobble (sin wave)
                p.wobblePhase += p.wobbleSpeed;
                p.x += Math.sin(p.wobblePhase) * p.wobbleAmount;

                // Remove if dead or offscreen
                if (p.life >= p.maxLife || p.y > window.innerHeight + 20) {
                    p.active = false;
                    activeParticles.splice(i, 1);
                }
            }
        }

        // Draw all particles
        function drawParticles() {
            // Clear particle canvas
            particleCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
            particleCtx.shadowBlur = 0;

            for (const p of activeParticles) {
                const baseAlpha = p.alpha;

                // Draw subtle glow (only for larger particles)
                if (p.size > 3.5) {
                    particleCtx.shadowBlur = 6;
                    particleCtx.shadowColor = p.color;
                } else {
                    particleCtx.shadowBlur = 0;
                }

                particleCtx.fillStyle = p.color;
                particleCtx.globalAlpha = baseAlpha;

                // Draw as circle
                particleCtx.beginPath();
                particleCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                particleCtx.fill();
            }

            // Reset canvas state
            particleCtx.globalAlpha = 1;
            particleCtx.shadowBlur = 0;
        }

        // Draw functions with Stranger Things neon glow
        function drawRect(x, y, width, height, color) {
            // Outer glow
            ctx.shadowBlur = 20;
            ctx.shadowColor = color;
            ctx.fillStyle = color;
            ctx.fillRect(x, y, width, height);

            // Extra glow layers
            ctx.shadowBlur = 40;
            ctx.fillRect(x, y, width, height);

            ctx.shadowBlur = 0;
        }

        function drawCircle(x, y, radius, color) {
            // Outer glow
            ctx.shadowBlur = 25;
            ctx.shadowColor = color;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();

            // Extra glow
            ctx.shadowBlur = 45;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;
        }

        function drawNet() {
            const netWidth = 2;
            const netHeight = 10;
            const gap = 15;

            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ff0040';
            ctx.fillStyle = '#ff0040';

            for (let i = 0; i < canvas.height; i += netHeight + gap) {
                ctx.fillRect(canvas.width / 2 - netWidth / 2, i, netWidth, netHeight);
            }

            ctx.shadowBlur = 0;
        }

        function draw() {
            // Clear canvas with solid black
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Apply screen shake/tilt if unstable
            ctx.save();
            if (stabilitySystem.mode === "UNSTABLE" && stabilitySystem.shakeIntensity > 0) {
                const shake = stabilitySystem.shakeIntensity;
                const offsetX = (Math.random() - 0.5) * 10 * shake;
                const offsetY = (Math.random() - 0.5) * 10 * shake;
                const rotation = (Math.random() - 0.5) * 0.05 * shake;

                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.rotate(rotation);
                ctx.translate(-canvas.width / 2 + offsetX, -canvas.height / 2 + offsetY);
            }

            // Draw net
            drawNet();

            // Draw obstacles (rift debris)
            if (stabilitySystem.obstacles.length > 0) {
                drawObstacles();
            }

            // Draw paddles with neon red glow
            drawRect(player.x, player.y, player.width, player.height, '#ff0040');
            drawRect(computer.x, computer.y, computer.width, computer.height, '#ff0040');

            // Draw ball with bright cyan/pink glow (enhanced during Telekinesis)
            if (telekinesisSystem.active) {
                // Add cyan aura during Telekinesis
                ctx.shadowBlur = 50;
                ctx.shadowColor = '#00d4ff';
                ctx.fillStyle = 'rgba(0, 212, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius * 2.5, 0, Math.PI * 2);
                ctx.fill();

                // Draw ball with cyan tint
                drawCircle(ball.x, ball.y, ball.radius, '#00ffaa');
            } else {
                // Normal pink ball
                drawCircle(ball.x, ball.y, ball.radius, '#ff6b9d');
            }

            ctx.restore(); // End shake transform

            // Draw game over screen
            if (game.isOver) {
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Winner text with intense glow
                ctx.fillStyle = '#ff0040';
                ctx.font = 'bold 64px "Bebas Neue"';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 30;
                ctx.shadowColor = '#ff0040';

                const winner = game.playerScore >= game.maxScore ? 'PLAYER WINS!' : 'COMPUTER WINS!';
                ctx.fillText(winner, canvas.width / 2, canvas.height / 2 - 40);

                // Restart instruction
                ctx.font = '28px "Bebas Neue"';
                ctx.shadowBlur = 20;
                ctx.fillText('Press SPACE or ENTER to restart', canvas.width / 2, canvas.height / 2 + 40);

                ctx.shadowBlur = 0;
            }
        }

        // Update game logic
        function update(dt) {
            // Update and draw particles (always, even when game is over)
            updateParticles();
            drawParticles();

            // Update power system (always)
            updatePower(dt);
            updatePowerBarUI();

            // Update Telekinesis UI (always)
            updateTelekinesisBarUI();

            // Update stability system (always)
            updateStability(dt);
            updateStabilityBarUI();

            // Skip update if game is over
            if (game.isOver) return;

            // Move player paddle with keyboard OR mouse (not both)
            if (usingKeyboard) {
                if (keys.up && player.y > 0) {
                    player.y -= player.speed;
                }
                if (keys.down && player.y < canvas.height - player.height) {
                    player.y += player.speed;
                }
            } else {
                // Move player paddle with mouse
                const targetY = mouseY - player.height / 2;
                if (Math.abs(targetY - player.y) > 2) {
                    if (targetY > player.y && player.y < canvas.height - player.height) {
                        player.y += player.speed;
                    } else if (targetY < player.y && player.y > 0) {
                        player.y -= player.speed;
                    }
                }
            }

            // Computer AI - follows ball with some delay
            const computerCenter = computer.y + computer.height / 2;
            const ballCenter = ball.y;

            if (ballCenter < computerCenter - 35) {
                computer.y -= computer.speed;
            } else if (ballCenter > computerCenter + 35) {
                computer.y += computer.speed;
            }

            // Keep computer paddle in bounds
            if (computer.y < 0) computer.y = 0;
            if (computer.y > canvas.height - computer.height) {
                computer.y = canvas.height - computer.height;
            }

            // Update Telekinesis steering (if active)
            updateTelekinesis(dt / 1000); // Convert dt from ms to seconds

            // Move ball
            ball.x += ball.speedX;
            ball.y += ball.speedY;

            // Ball collision with top and bottom walls
            if (ball.y - ball.radius <= 0 || ball.y + ball.radius >= canvas.height) {
                ball.speedY = -ball.speedY;
            }

            // Ball collision with player paddle
            if (ball.x - ball.radius <= player.x + player.width &&
                ball.y >= player.y &&
                ball.y <= player.y + player.height &&
                ball.speedX < 0) {

                // Calculate hit position on paddle (-1 to 1)
                const hitPos = (ball.y - (player.y + player.height / 2)) / (player.height / 2);
                const angle = hitPos * Math.PI / 4; // Max 45 degrees

                const speed = Math.sqrt(ball.speedX * ball.speedX + ball.speedY * ball.speedY);
                ball.speedX = Math.abs(Math.cos(angle) * speed);
                ball.speedY = Math.sin(angle) * speed;

                // Increase speed slightly
                ball.speedX = Math.min(ball.speedX * 1.05, ball.maxSpeed);
                ball.speedY = Math.min(Math.abs(ball.speedY) * 1.05, ball.maxSpeed) * Math.sign(ball.speedY);

                // Increment hit streak for power system
                incrementHitStreak();

                // Increment Telekinesis hit streak
                incrementTelekinesisStreak();
            }

            // Ball collision with computer paddle
            if (ball.x + ball.radius >= computer.x &&
                ball.y >= computer.y &&
                ball.y <= computer.y + computer.height &&
                ball.speedX > 0) {

                // Calculate hit position on paddle (-1 to 1)
                const hitPos = (ball.y - (computer.y + computer.height / 2)) / (computer.height / 2);
                const angle = hitPos * Math.PI / 4; // Max 45 degrees

                const speed = Math.sqrt(ball.speedX * ball.speedX + ball.speedY * ball.speedY);
                ball.speedX = -Math.abs(Math.cos(angle) * speed);
                ball.speedY = Math.sin(angle) * speed;

                // Increase speed slightly
                ball.speedX = Math.max(ball.speedX * 1.05, -ball.maxSpeed);
                ball.speedY = Math.min(Math.abs(ball.speedY) * 1.05, ball.maxSpeed) * Math.sign(ball.speedY);
            }

            // Score detection
            if (ball.x - ball.radius <= 0) {
                // Computer scores (player missed)
                game.computerScore++;
                updateScore();
                resetBall(1);
                resetHitStreak(); // Reset power charge on miss
                resetTelekinesisStreak(); // Reset Telekinesis charge on miss
            } else if (ball.x + ball.radius >= canvas.width) {
                // Player scores
                game.playerScore++;
                updateScore();
                resetBall(-1);
            }

            // Check for game over
            if (game.playerScore >= game.maxScore || game.computerScore >= game.maxScore) {
                game.isOver = true;
            }
        }

        function resetBall(direction) {
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.speedX = 5 * direction;
            ball.speedY = (Math.random() * 2 - 1) * 5;
        }

        function updateScore() {
            document.getElementById('playerScore').textContent = game.playerScore;
            document.getElementById('computerScore').textContent = game.computerScore;
        }

        function resetGame() {
            game.playerScore = 0;
            game.computerScore = 0;
            game.isOver = false;
            updateScore();
            resetBall(Math.random() > 0.5 ? 1 : -1);
            // Reset paddle positions
            player.y = canvas.height / 2 - paddleHeight / 2;
            computer.y = canvas.height / 2 - paddleHeight / 2;
            // Reset power system
            resetHitStreak();
            resetTelekinesisStreak();
            telekinesisSystem.active = false; // Deactivate Telekinesis if active
            if (powerSystem.activePower) {
                powerSystem.activePower.onEnd();
                powerSystem.activePower = null;
            }
            // Reset stability system
            stabilitySystem.mode = "STABLE";
            stabilitySystem.stability = 100;
            stabilitySystem.stableTimer = 0;
            stabilitySystem.unstableTimer = 0;
            stabilitySystem.obstacles = [];
            stabilitySystem.shakeIntensity = 0;
        }

        // Game loop with delta time
        let lastTime = performance.now();
        function gameLoop(currentTime) {
            const dt = currentTime - lastTime;
            lastTime = currentTime;

            update(dt);
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start game
        resetBall(-1);
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
